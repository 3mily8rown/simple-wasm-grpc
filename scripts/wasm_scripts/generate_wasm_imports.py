#!/usr/bin/env python3
import re
import subprocess
import argparse

def parse_types(wasm_path):
    """
    Build a map: sig_idx -> (args_letters, ret_letter).
    E.g. for:
      Type[2] func(i32,i32) -> i32    → {2:("ii","i")}
      Type[0] func(i32,i32,i32)       → {0:("iii","")}
    """
    out = subprocess.check_output(["wasm-objdump", "-x", wasm_path], text=True)
    sigs = {}
    tmap = {"i32":"i", "i64":"i", "f32":"f", "f64":"f"}
    type_re = re.compile(
        r'\s*-\s+type\[(\d+)\]'       # "- type[<idx>]"
        r'\s*\(\s*([^)]*?)\s*\)'           # " ( i32, i32 )"
        r'(?:\s*->\s*(\w+))?'           # optional "-> i32" or "-> nil"
    )

    for line in out.splitlines():
        m = type_re.match(line)
        if not m:
            continue
        idx       = int(m.group(1))
        params    = [p.strip() for p in m.group(2).split(',')] if m.group(2) else []
        ret_wasm = m.group(3) or ""      # captures "i32" or "nil"
        ret_letter = {"i32":"i","i64":"i","f32":"f","f64":"f"}.get(ret_wasm, "")
        # so "nil" → "", "i32" → "i"
        args      = "".join(tmap.get(p, "i") for p in params)
        sigs[idx] = (args, ret_letter)
    return sigs

def parse_imports(wasm_path):
    """
    Parse lines like:
      - func[0] sig=2 <get_pow(int, int)> <- env._Z7get_powii
    into [(mangled, base, sig_idx, demangled_sig), ...]
    """
    out = subprocess.check_output(["wasm-objdump", "-x", wasm_path], text=True)
    imps = []
    imp_re = re.compile(
        r'\s*-\s+func\[\d+\]\s+sig=(\d+)\s+<([^>]+)>\s+<-\s+env\.([^ ]+)'
    )
    for line in out.splitlines():
        m = imp_re.match(line)
        if not m:
            continue
        idx, dem, mangled = m.groups()
        base = dem.split('(')[0]
        imps.append((mangled, base, int(idx), dem))
    return imps

def collapse_ptr_len(dem_sig):
    """
    Collapse the first char*+int pair into '*~i', dropping further params. (matches intToStr on wamr examples)
    """
    inside = dem_sig[dem_sig.find('(')+1 : dem_sig.rfind(')')]
    parts = [p.strip() for p in inside.split(',')] if inside else []
    out, i = [], 0
    while i < len(parts):
        if parts[i]=='char*' and i+1<len(parts) and parts[i+1]=='int':
            out.append('*~i')
            break
        out.append('i')
        i += 1
    return "".join(out)

def emit_header(imports, type_sigs, header_path, module):
    arr = f"generated_{module}_native_symbols"
    cnt = f"{arr}_count"
    with open(header_path, "w") as f:
        f.write("// AUTO-GENERATED by generate_wasm_imports.py\n")
        f.write("#pragma once\n\n#include \"native_impl.h\"\n\n")
        f.write(f"static NativeSymbol {arr}[] = {{\n")
        for mangled, base, idx, dem in imports:
            # lookup exact signature
            args, ret = type_sigs.get(idx, (None, None))
            if args is None:
                # fallback → all params 'i', void return
                inside = dem[dem.find('(')+1 : dem.rfind(')')]
                parts  = [p.strip() for p in inside.split(',')] if inside else []
                args   = "".join('i' for _ in parts)
                ret    = ""
            # collapse pointer+length if present
            if 'char*' in dem:
                args = collapse_ptr_len(dem)
            f.write(f'  {{ "{mangled}", (void*){base}, "({args}){ret}", nullptr }},\n')
        f.write("};\n\n")
        f.write(f"static const size_t {cnt} = sizeof({arr})/sizeof(NativeSymbol);\n")

def main():
    p = argparse.ArgumentParser(description="Generate WAMR native symbol table")
    p.add_argument("--module", required=True, help="Prefix for symbols")
    p.add_argument("wasm", help="Input .wasm file")
    p.add_argument("header", help="Output C++ header path")
    args = p.parse_args()

    type_sigs = parse_types(args.wasm)
    imps      = parse_imports(args.wasm)
    emit_header(imps, type_sigs, args.header, args.module)

if __name__ == "__main__":
    main()
